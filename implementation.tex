\section{QSV Applications}
\label{sec:implementation}

%\liyi{Symbolic execution, and compiler.}

This section presents QSV applications, based on \pqasm programs, to validate and compile the programs.
%where we view \pqasm as a framework for specifying, compiling, and testing quantum state preparation programs.
%whose architecture was given in \Cref{fig:arch}.
We start by discussing QSV's PBT framework for \pqasm programs. 
Next, we consider translation from \pqasm to \sqir and proof of its correctness. 
%Next, we discuss \pqasm's property-based random testing framework for \pqasm programs. 
%Finally, we discuss \vqimp, a simple imperative language for writing oracles, which compiles to \pqasm. We also present its proved-correct compiler and means to test the correctness of \vqimp oracles.

%the qubit state side-effects of adding a number to qubit state phases caused by an $\texttt{SR}$ gate
%We utilize the lemma below to show the qubit state side-effects of the phase addition caused by an $\texttt{SR}$ gate when we transform the state from \texttt{Phi} to \texttt{Nor}-basis by applying a  $\texttt{QFT}^{-1}$ gate.
%After such transformation, phase changes are transformed into changes in qubit state bases.
%\mwh{Don't understand the previous statement. The rzadder program never references SR-inverse. It does reference \texttt{Rev} but you never mention that.} \liyi{modified. }
%\mwh{The modification didn't help me. You still mention $\texttt{SR}^{\lbrack -1 \rbrack}$ but I don't know why; it appears nowhere in the code for this circuit.}
%The side-effect depends on the $m$ value of the state basis type $\texttt{Phi}\;m$.
%For the example in \Cref{fig:circuit-example}, the \texttt{QFT} gate 
%turns \code{b}'s basis to $\texttt{Phi}\;(\Sigma($\code{b}$))$, which is an exact QFT instead of an AQFT gate.
%In this case, the effect of applying an  $\texttt{SR}^{\lbrack -1 \rbrack}$ gate onto the \texttt{Nor}-basis state is as follows:
%\begin{lemma}\label{thm:true-meaning}\rm
%For a variable $x$ having type $\texttt{Phi}\;(\Sigma(x))$, let $y$ being the result \texttt{Nor}-basis state by applying $\texttt{QFT}^{-1}$ to $x$; thus, applying $\isr{n}{x}$ following by a $\texttt{QFT}^{-1}$ gate means to add $2^{\Sigma(x)-n-1}$ to $y$;
%and applying $\isr[-1]{n}{x}$ following by a $\texttt{QFT}^{-1}$ gate means to subtract $2^{\Sigma(x)-n-1}$ from $y$; .
%\end{lemma}
%\liyi{might not need the following.}
%In short, with the lemmas above, we first inductively show the effect of applying a series of $\texttt{SR}$ gates to variable %\texttt{b}'s qubit state phases as shown in the QFT-adder circuit \Cref{fig:circuit-example}.
%Then, we utilize \Cref{thm:true-meaning} to show the computation result of the phase manipulation transformation to \texttt{b}'s qubit state bases after applying a $\texttt{QFT}^{-1}$ gate.

\subsection{PQASM Typing for Effectively Validating State Preparation Programs}\label{sec:rand-testing}

%Full formal proof is the gold standard for correctness, but it is also laborious. It is especially deflating to be well through a proof only to discover that the intended property does not hold and, worse, that nontrivial changes to the program are necessary. 
The QSV validator is built on PBT to give assurance that a \pqasm program property is correct by attempting to falsify it using thousands of randomly generated instances with good coverage of the program's input space. We have used PBT to validate the correctness of a variety of state preparation programs, presented in \Cref{sec:evaluation}.
Below, we show our validator construction.

% Proofs of operator correctness can be time-consuming and repetitive.
\pqasm's state representation and type system ensure that states can be represented effectively.
We leverage this fact to implement a validation framework for \pqasm programs using QuickChick \cite{quickchick}, a property-based testing (PBT) framework for Rocq in the style of Haskell's QuickCheck~\cite{10.1145/351240.351266}. We use this framework for two purposes: to validate the correctness properties of \pqasm programs and to experiment with effective implementations of correct state preparation programs.
\pqasm contains measurement operations, which, due to the randomness inherent in quantum measurement, are difficult to test effectively, even with the assistance of program abstractions.
To have an effective validation framework, we restrict the properties that can be questioned to solely focus on the properties related to program correctness.

\noindent\textbf{\textit{Implementation.}}
PBT randomly generates inputs using a hand-crafted \emph{generator} and confirms that a property holds for these inputs. 
We develop a validation toolchain, based on the methodology in \Cref{sec:motivation}, using the symbolic state representation concept and carefully selecting the properties to validate for a program. 

\begin{figure}[h]
\vspace*{-1em}
  \includegraphics[width=0.8\textwidth]{pqasm}
   \caption{The Flow of PBT for QSV}
   \vspace*{-0.7em}
\label{fig:testing}
\end{figure}

The flow of the QSV PBT framework is given in \Cref{fig:testing}.
To validate a \pqasm program, we first utilize our \pqasm type system to generate a type environment $\Omega$ for qubits in a program $e$,
i.e., $\emptyset;\emptyset\vdash e \triangleright \Omega$, typing with an empty kind and type environment.
Essentially, $\Omega$ partitions all qubits used in $e$ into three sets $(\overline{q_1}, \overline{q_2}, \overline{q_3})$, with $\overline{q_1}$ containing all qubits in $\thadt$ type.
In \pqasm, once a qubit is turned into $\thadt$, it stays in the type.
We utilize the property to locate all the $\thadt$ typed qubits in a program $e$ and generate random testing data based on these qubits,
i.e., we identify the set $\overline{q_1}$ in $\Omega$ as the set of $\thadt$ typed qubits and generate random boolean values in $\{0,1\}$ for variables in the set.

Second, we assume that a program is in the form of $e=\iseq{\inew{\overline{q}}}{\iseq{\ihad{\overline{q}}}{e'}}$ \footnote{$\inew{\overline{q}}$ and $\ihad{\overline{q}}$ are syntactic sugar for multiple $\inew{q}$ and $\ihad{q}$ operations.},
i.e., all the $\cn{new}$ and $\cn{H}$ operations appear in the front of the program and $e'$ does not contain any such operations.
We then split the program by taking the $e'$ part and removing the $\cn{new}$ and $\cn{H}$ operations, and assuming that these operations have been applied.
For some program patterns, such as repeat-until-success programs, we replace recursive process variables in $e'$ with $\sskip$ operations so that we only validate one step of a repeat-until-success, because every recursive step in these programs is interdependent. 
One example of programming splitting for \Cref{def:circuit-example} is given below; it removes the part $\iseq{\inew{\overline{q}}}{\iseq{\inew{q'}}{\ihad{\overline{q}}}}$ and replacing $P$ with $\sskip$.

{\small
\begin{center}
$
P'={\iseq{\qbool{\overline{q}}{<}{n}{q'}}{\smea{x}{q'}{\sifb{x=1}{\sskip}{\sskip}}}}
$
\end{center}
}

The ``Test Gen'' step in our PBT framework (\Cref{fig:testing}) generates test cases to validate the key component $P'$ above.
In \Cref{def:circuit-example}, after applying the \cn{new} and \cn{H} operations, the post-state is $(\Phi,P')$, with $\Phi$ mapping $\theta$, entanglement groups, to superposition states $\varphi$. Each \cn{H} operation generates a single qubit uniformly distributed superposition state.
However, transitions over a superposition state make it hard to perform effective validation.
To resolve this, we treat quantum program operations $P'$ as higher-order map operations and validate the transition correctness based on basis-kets, instead of validating over the whole superposition state.

Generally, $\varphi$ can be written in the Dirac notation of $\sum_j \rho_j$ with $\rho_j = z_j \cdot \eta_j$,
i.e., given $\theta =(b_0,b_1,...,b_m,\overline{q_2},\overline{q_3})$, the superposition state $\varphi$ could also be written as the follows.

{\small
\begin{center}
$
\sum_{b_0=0}^1 \sum_{b_1=0}^1 ... \sum_{b_m=0}^1 z(b_0,b_1,...,b_m)\cdot \eta({b_0,b_1,...,b_m})
$
\end{center}
}

%the post-state after applying \cn{new} and \cn{H} ops is $(\theta \to z\cdot \eta,P')$, with $z\cdot \eta$ being a representative basis-ket state based on $\varphi$ above. 
%Clearly, $\varphi$ can be written in the Dirac notation of $\sum_j \rho_j$ with $\rho_j = z_j \cdot \eta_j$,
%so picking a representative basis-ket state could be an arbitrary $j$-th basis-ket, i.e., $z_j \cdot \eta_j$.
%Given $\theta =(b_0,b_1,...,b_m,\overline{q_2},\overline{q_3})$, the superposition state $\varphi$ could also be written as the follows.

Here, $b_0$, $b_1$, ..., $b_m$ are qubit variables assumed to be already manipulated by the initial \cn{H} operations, e.g., $P'$ above assumes that $\overline{q}$ were manipulated by \cn{H} operations.
Applying a \cn{H} operation to a $\tnort$ typed qubit $\aket{b_a}{1}$ creates a uniformly distributed superposition $\sum_{b=0}^1 \frac{1}{\sqrt{2}} (-1)^{b\cdot b_a} \aket{b}{1}$, so it results in the state form above, with $z(b_0,b_1,...,b_m)$ being an amplitude formula and $\eta({b_0,b_1,...,b_m})$ being a basis-vector formula.
We can then select the symbolic basis-ket state $z(b_0,b_1,...,b_m)\cdot \eta({b_0,b_1,...,b_m})$ as the representative basis-ket and rewrite the $\varphi$ state to be in the form $(\theta \to z\cdot \eta,P')$ for validation, with $b_0$, $b_1$, ..., $b_m$ acting as random variables.
For each random variable $b_j$, we can randomly choose the value $b_j\in\{0,1\}$ for a particular test instance.
Thus, for $m$ qubits, we have $2^m$ different test instances depending on the different value selection for the random variables.

For the $P'$ program above, we view each element in the $ m$-qubit array $\overline{q}$ as a random variable.
Then, we generate an initial state $(\theta \to z(\overline{q}[0],...,\overline{q}[m\sminus 1])\cdot \eta(\overline{q}[0],...,\overline{q}[m\sminus 1]),P')$
with $\overline{q}[0],...,\overline{q}[m\sminus 1]$ being random variables and $\theta=(\overline{q},q,\emptyset)$.
We can then generate test instances for choosing different variables for $\overline{q}[j]$ with $j\in[0,m)$.

Once we randomly generate test instances, we can then validate the program by running each test instance in our \pqasm interpreter, developed based on our program semantics.
The result of the interpreter is provided as input to a specification checker to validate if the specification is satisfied.
If the checker makes all test instances answer \cn{true}, we validate the program; otherwise, we report a fault in the program.
Below, we show the construction of the specification checker to validate the program's correctness and other properties.

\noindent\textbf{\textit{Validating Correctness.}}
We first run a test instance in our interpreter with the initial state, as $(\theta \mapsto z\cdot \eta, P)\longrightarrow^*(\theta' \mapsto z'\cdot \eta',\sskip)$, where $\theta \equiv \theta'$. For a user-specified property $\psi$, a satisfiability check is applied to $\psi(z \cdot \eta, z' \cdot \eta')$ by replacing variables with $z \cdot \eta$ and  $z' \cdot \eta'$.
%In testing the correctness, a general pattern for the property $\psi$ is listed as follows.
Recall that we demonstrate a transformation of correctness property in \Cref{sec:intro} for the program in \Cref{def:circuit-example},
to conduct validation on individual basis-kets rather than the whole quantum state.
Such property transformations can be summarized as the transformation from (1) to (3) as below:

{\footnotesize
\begin{center}
$
\text{(1) }
\sum_j z_j \cdot \eta_j \to f(\sum_j z_j \cdot \eta_j)
\qquad
\text{(2) }
\sum_j z_j \cdot \eta_j \to \sum_k g(z_k \cdot \eta_k) \wedge \phi(k)
\qquad
\text{(3) }
\forall j. z_j \cdot \eta_j \to g'(z_j \cdot \eta_j) \wedge \phi(j)
$
\end{center}
}

The correctness property should be written in the format of (3).
The property (1) describes the program semantics, i.e., given a superposition state $\sum_j r_j \cdot \eta_j$, $f$ represents the semantic function for a program $e$.
The effects of such a function can always be in the form of a linear sum by moving the sum operator to the front, as in (2): one can always find $g$ such that $f(\sum_j r_j \cdot \eta_j) = \sum_k g(r_k \cdot \eta_k)$.
In some cases, we might need to insert the $\phi(k)$ predicate above, constraining index $k$ in the sum operator.
Here, both $j$ and $k$ are indices for two different sum operators.
Often, the function $g$ can be turned into an equivalent form $g'$ based on the index $j$.
Once we equate the two indices, we can then transform the formula to (3) without any sum operators, via the axiom of extensionality.
Such transformation might come with the index restriction $\phi$ based on index $j$, as shown in (3),
which refers to the fact that we start with a superposition state with a representative basis-ket state $r_j \cdot \eta_j$ and output a basis-ket state $g'(r_j \cdot \eta_j)$, with the post-state index restriction $\phi(j)$.

To validate $P'$ above, we transform the correctness property from the left to the right one below ($\Rightarrow$ is logic implication).

{\small
\begin{center}
$
x = 1 \Rightarrow \sum_j^{2^m}\frac{1}{\sqrt{2^m}}\aket{j}{m}\aket{0}{1} \to \sum_j^{n}\frac{1}{\sqrt{n}}\aket{j}{m}
\qquad
\forall j\in[0,2^m)\,.\, x = 1 \Rightarrow \aket{j}{m}\aket{0}{1} \to \aket{j}{m} \wedge j < n
$
\end{center}
}

The right property states that, if the measurement results in $1$ ($x = 1$), each basis-ket in the pre-state for $\overline{q}$ and $q$ respectively have the basis vector forms $\aket{j}{m}$ and $\aket{0}{1}$, and results in $\overline{q}$ being the same $\aket{j}{m}$ with the restriction $j < n$.
The ${\otimes m}$ and ${\otimes 1}$ flags refer to the number of qubits in quantum array variables $\overline{q}$ and $q$.
%Essentially, each basis vector state is a bitstring, and a flag ${\otimes m}$ identifies a bitstring with length $m$.
In implementing a validation property, the flag essentially indicates the length of a bitstring piece, which is cast into a natural number for comparison.
%
To validate the correctness property against $P'$, we create a length $m$ bitstring for $\aket{j}{m}$ and view $j[k]$, for $k\in[0,m)$, being the $k$-th bit in the bitstring.
Recall that $P'$ has an initial basis vector state pattern as $\aket{\overline{q}[0]}{1}...\aket{\overline{q}[m\sminus 1]}{1}\aket{0}{1}$.
Here, $\aket{0}{1}$ is the state for qubit $q$ and $\overline{q}[0],...,\overline{q}[m\sminus 1]$ are random variables for qubit array $\overline{q}$.
To check the property, we bind each $j[k]$ with $\overline{q}[k]$ for $k\in[0,m)$, and see if the output basis-ket state results in the same $\overline{q}[0],...,\overline{q}[m\sminus 1]$. We also check if $\overline{q}$'s natural number representation is less than $n$,
i.e., we turn $\overline{q}[0],...,\overline{q}[m\sminus 1]$ to a number and compare it with $n$.

%\noindent\textbf{\textit{Testing Correctness.}}
%
% We have used PBT to test the correctness of a
%variety of operators useful in oracle programs, as presented in
%\Cref{sec:arith-oqasm}. When implementing a QFT-adder circuit, using
%PBT revealed that we had encoded the wrong endianness. 
%We have also used PBT with \vqimp programs by first
%compiling them to \pqasm and then testing their correctness at that
%level.

\noindent\textbf{\textit{Validating Other Properties.}}
The above procedure is only useful in validating correctness.
There might be other interesting properties, such as probability and effectiveness properties.
For example, in validating \Cref{def:circuit-example}, we might want to ask how likely the qualified state can be prepared,
which is hard to validate in general, but it can be effectively sampled out in some cases.


{\small
\begin{center}
$
x = 1 \Rightarrow \sum_j^{2^m}\frac{1}{\sqrt{2^m}}\aket{j}{m}\aket{0}{1} \to \sum_j^{n}\frac{1}{\sqrt{n}}\aket{j}{m}
$
\end{center}
}

In the superposition state-based property for $P'$ above, the number of qubits in $\overline{q}$ is $m$ and $n\in[0,2^m)$.
Here, let's see how to validate the effectiveness of the program, i.e., the probability that the repeat-until-success program produces the correct state.
Note that superposition states are always uniformly distributed without any \cn{Ry} operations.
The success rate of preparing a superposition state in the repeat-until-success scheme is the ratio between the number of possible basis-vector values less than $n$ and the total number of possible basis-vector values, i.e., $\overline{q}[0],...,\overline{q}[m\sminus 1]$. We can validate the effectiveness by calculating the number of possible values $\overline{q}$ less than $n$, by interpreting $\overline{q}$ as a natural number, dividing the number of possible values in $\overline{q}$; that is, $2^m$.

In general, assume that we have a basis-vector expression $e(\overline{q})$ for $m$ qubits $\overline{q}$, a measurement statement $\mathpzc{M}\cn{(}e(\overline{q})\cn{)}$ storing the result in $v$, and have a boolean check on $v$ as $B(v)$ defining the good states.
By assigning $\{0,1\}^m$ for $\overline{q}$, the probability of having the good states is the division of number of possible basis-vector values with $B(e(\overline{q}))=\cn{true}$ and the number of possible basis-vector values $e(\overline{q})$ for all possible assignments.
In \Cref{fig:intros-example}, the effectiveness can be described as $\frac{n}{2^m}$; such a property can be validated by sampling.
In some complicated cases, the right property might be hard to validate, but one can always use Rocq to verify the effectiveness via the above scheme.

\noindent\textbf{\textit{Performance Optimizations.}}
%
We took several steps to improve validation performance, e.g., we streamlined the representation of states: per the semantics in \Cref{fig:deno-sem}, in a state with $n$ qubits, the amplitude associated with each qubit can be written as $\Delta(\frac{\upsilon}{2^n})$ for some natural number $\upsilon$. 
Qubit values in both bases are thus pairs of natural numbers: the global phase $\upsilon$ (in range $[0,2^n)$) and $b$ (for $\aket{b}{1}$) or $y$ (for $\qket{\frac{y}{2^n}}$). 
An \pqasm state $\varphi$ is a map from qubit positions $p$ to qubit values $q$; in our proofs, this map is implemented as a partial function, but for validation, we use an AVL tree implementation (proved equivalent to the functional map). 
To avoid excessive stack use, we implemented the \pqasm semantics function tail-recursively. 
To run the tests, QuickChick runs OCaml code that it \emph{extracts} from the Rocq definitions; during extraction, we replace natural numbers and operations thereon with machine integers and operations. Performance results are in \Cref{sec:evaluation}.



% There are two modes of the comparison framework. First, we randomly generate same inputs for the two circuits, and answer the question how many percentages of outputs are exactly the same. If the difference rate is small, in some cases, the approximate circuit could be useful. Second, we also generate same inputs for the two circuits and answer the question that what parts in the output bitstrings are exactly the same. In analyzing circuits and their approximate implementations, most likely, a circuit might produce results that are almost always different from the results from its approximate implementation. However, some parts of their outputs might be the same. For example, in comparing the QFT-based addition circuit and the AQFT-based one, we find that the result high bits that are within the AQFT precision number range are the same as long as the low bits do not produce extra carry bit.
% Then, we can utilize the similarity being discovered in our framework to construct other useful oracles. See \Cref{sec:qft-case}.

% For PBT to be efficient, careful consideration must be given to the datatypes used to represent program states.
% As shown in \Cref{def:well-formed}, all possible phase values have the form $e^{2 \pi i b}$ for some real value $b$.In our implementation, we consider a finite approximation of $b$, such that there is a bitstring $[\upsilon]_n$ with $b\approx\frac{1}{2^{1\cdot [\upsilon]_n(k)}}+...+\frac{1}{2^{n-k\cdot [\upsilon]_n(n-1)}}$.
% This is why we have a smallest phase precision number $r_0$ (represented by the $n$ here) in translation from \pqasm to \sqir.
% Obviously, $[\upsilon]_n$ can be represented by a natural number $\upsilon$.
% The remaining issue is that we need to find a good number representation of $b$, so that phase rotation gate applications ($\texttt{RZ}^{[-1]}$ and $\texttt{SR}^{[-1]}$) can be implemented by natural number operations.
% We choose to record $b$ as a number $\upsilon'$ whose bitstring representation is $\texttt{rev}([\upsilon]_n)$ \footnote{$\texttt{rev}([c_1,...,c_n])=[c_n,...,c_1]$}, i.e, $[\upsilon']_n=\texttt{rev}([\upsilon]_n)$, where $[\upsilon]_n$ is the bitstring mentioned above.
% Then, applying the operation $(\upsilon'+2^{n - j})\%2^{n}$ is exactly the same as applying a phase rotation $e^{\frac{2 \pi i}{2^j}}$ to $b$ as $e^{2\pi i * (b+\frac{1}{2^j})}$, and applying $(\upsilon'+2^{n}-2^{n - j})\%2^{n}$ is the same as applying a phase rotation $e^{-\frac{2 \pi i}{2^j}}$ to $b$ as $e^{2\pi i * (b-\frac{1}{2^j})}$.
% Since $\texttt{SR}^{[-1]}$ is a series of $\texttt{RZ}^{[-1]}$, the $\upsilon'$ representation allows us to represent phases (and phase rotations) as natural numbers (and arithmetic operations)

\subsection{Translation from \pqasm to \sqir}\label{sec:vqir-compilation}

\newcommand{\tget}{\texttt{get}}
\newcommand{\tstart}{\texttt{start}}
\newcommand{\tfst}{\texttt{fst}}
\newcommand{\tsnd}{\texttt{snd}}
\newcommand{\tucom}[1]{\texttt{ucom}~{#1}}
\newcommand{\tif}{\texttt{if}}
\newcommand{\tthen}{\texttt{then}}
\newcommand{\telse}{\texttt{else}}
\newcommand{\tlet}{\texttt{let}}
\newcommand{\tin}{\texttt{in}}

We translate \pqasm to \sqir by mapping \pqasm virtual qubits to \sqir concrete qubit indices and expanding \pqasm instructions to sequences of \sqir gates.
\sqir \cite{VOQC} is a quantum circuit language based on Rocq, containing standard quantum gates, such as Hadamard, controlled, and \cn{Ry} gates, sequential operations, and quantum measurement operations.
To express the classical components of quantum algorithms, \sqir typically utilizes Rocq program constructs.
To define our compiler, we utilize the \sqir one-step non-deterministic semantics, containing one-step operational semantics for simple Rocq constructs, such as conditionals and classical sequential operations.


% Most \pqasm instructions are easily mapped to operations in \sqir, with the exception of the position shifting instructions.  
% The difficulty there is the virtual-to-physical qubit compilation.
% In \pqasm, a position $p$ is a pair of a qubit variable and offset, not
% a physical qubit location in a quantum circuit. We keep track of a map
% from each \pqasm position to a concrete \sqir qubit index.
%
The \pqasm to \sqir translation is expressed as the two-level judgments
$\Xi\vdash \iota \gg \epsilon$ and $(n,\Xi, e) \gg (n',\Xi',\chi)$, where $\epsilon$ is the output \sqir circuit, and $\Xi$ and $\Xi'$ map an \pqasm qubit $q$ to a \sqir concrete qubit index (i.e., offset into a  global qubit register), $\chi$ is a hybrid program including \sqir quantum circuits and Rocq classical programs,
and $n$ and $n'$ are the qubit sizes in the whole system.

\begin{figure}[t]
\vspace*{-0.5em}
{\small
  \begin{mathpar}
    \inferrule[CRy]{}{\Xi \vdash \iry{r}{q} \gg (\gamma,\textcolor{blue}{\iry{r}{(\Xi(q))}})}
    
    \inferrule[CCU]{\Xi\vdash \instr \gg \textcolor{blue}{\epsilon}\\
      \textcolor{blue}{\epsilon' = \texttt{ctrl}(\gamma(q),\epsilon)}}{\Xi\vdash\ictrl{p}{\instr} \gg \textcolor{blue}{\epsilon'}}    
   
       \inferrule[CNext]{ \Xi \vdash \iota \gg \textcolor{blue}{\epsilon}}{(n,\Xi,\iota) \gg (n,\Xi,\textcolor{blue}{\epsilon})}             
    
     \inferrule[CHad]{}{(n,\Xi, \ihad{q}) \gg (n,\Xi, \ihad{\Xi(q)})}             
               
    \inferrule[CSeq]{ (n,\Xi, e_1) \gg (n',\Xi',\textcolor{blue}{\chi_1}) \\ (n',\Xi',e_2) \gg (n'',\Xi'',\textcolor{blue}{\chi_2})}{(n,\Xi,\sseq{e_1}{e_2}) \to (n'',\Xi'',\textcolor{blue}{\sseq{\chi_1}{\chi_2}})}             
  
    \inferrule[CNew]{\Xi'=\Xi[\forall q\in\overline{q}\,.\,q \mapsto \slen{\Xi}+\cn{ind}(\overline{q},q)]}{(n,\Xi, \inew{\overline{q}}) \gg (n+\slen{\overline{q}},\Xi', \sskip)}             
  
      \inferrule[CMea]{(n,\Xi \backslash \overline{q},e) \gg (n',\Xi',\textcolor{blue}{\chi})}{(n,\Xi,\smea{x}{\overline{q}}{e}) \to (n',\Xi',\textcolor{blue}{{\mathpzc{M}(\overline{q})};\chi})} 
  
  
  \end{mathpar}
}
\vspace*{-1em}
\caption{Select \pqasm to \sqir translation rules (\sqir circuits are marked blue). $\slen{\Xi}$: the length of $\Xi$; $\cn{ind}(\overline{q},q)$: the index of $q$ in array $\overline{q}$. $\textcolor{blue}{{\mathpzc{M}(\overline{q})}}$ repeats $\slen{\overline{q}}$ times on measuring qubit array $\overline{q}$.}
\label{fig:compile-vqir}
\vspace*{-1em}
\end{figure}

\Cref{fig:compile-vqir} depicts a selection of translation rules.
Rules \rulelab{CRy} and \rulelab{CCU} are the instruction level translation rules, which translate a \pqasm instruction to a \sqir unitary operation.
$\iry{r}{q}$ has a directly corresponding gate in \sqir.
In the \texttt{CU} translation, the rule assumes that $\instr$'s translation does not affect the $\Xi$ position map. This requirement is assured for well-typed programs per rule \rulelab{CU} in \Cref{fig:exp-well-typed}. 
 \texttt{ctrl} generates the controlled version of an arbitrary \sqir program using standard decompositions \cite[Chapter 4.3]{mike-and-ike}.

The other rules in \Cref{fig:compile-vqir} are the program level rules, which translate a \pqasm program to a hybrid Rocq program including \sqir circuits with possible measurement operations.
Rule \rulelab{CNext} connects the instruction and the program-level translations.
Rule \rulelab{CHad} translates a Hadamard operation to a \sqir Hadamard gate, while rule \rulelab{CSeq} translates a sequencing operator.

Rule \rulelab{CNew} translates a qubit creation operation in \pqasm.
In \sqir, there is no qubit creation, in the sense that every qubit is assumed to exist in the first place.
The translation essentially translates the operation to a SKIP operation in \sqir and increments the qubit heap size in the generated \sqir program.
Note that the qubit size in the translation is always incrementing, i.e., a quantum measurement does not remove qubits but just makes some qubits inaccessible.
Rule \rulelab{CMea} translates a \pqasm measurement operation to \sqir measurements by repeatedly measuring out qubits in $\overline{q}$.
The translation removes measured qubits from $\Xi$, but it does not modify the qubit size.

\newcommand{\transs}[3]{[\!|{#1}|\!]^{#2}_{#3}}

We have proved the \pqasm-to-\sqir translation correct.
The proof utilizes the \sqir nondeterministic semantics, where a qubit measurement produces two possible outcomes with different probabilities associated with the outcomes, 
i.e., this nondeterministic semantics is essentially \sqir's way of describing a Markov-chain procedure.
To formally state the correctness property, we relate \pqasm superposition states $\Phi$ to \sqir states, written as $\denote{\Phi}^{n'}$, which are vectors of $2^{n'}$ complex numbers.
We can utilize $\Xi$ to relate qubits in \pqasm with qubit positions in \sqir.
%
%For example, say that our program uses two variables, $x$ and $y$, and both have two qubits.
%The qubit states are $\ket{0}$ and $\ket{1}$ (meaning that $x$ has type \texttt{Nor}), and $\qket{r_1}$ and $\qket{r_2}$ (meaning that $y$ has type \texttt{Phi}).
%Furthermore, say that $\gamma = \{(x,0)\mapsto 0,(x,1)\mapsto 1, (y,0)\mapsto 2, (y,1)\mapsto 3\}$. 
%This \pqasm program state will be mapped to the $2^4$-element vector $\ket{0}\otimes \ket{1}\otimes (\ket{0}+e^{2\pi i r_1}\ket{1})\otimes (\ket{0}+e^{2\pi i r_2}\ket{1})$.

\begin{theorem}\label{thm:vqir-compile}\rm[Translation Correctness]
  Suppose $\Sigma; \Omega \vdash e \triangleright \Omega'$ and
  $(n,\Xi,e) \gg (n',\Xi',\chi)$.
Then for $\Omega \vdash \Phi$ and $(\Phi,e)\xrightarrow{r}(\Phi',e')$, we have $(\denote{\Phi}^{n'},\chi)\xrightarrow{r}(\denote{\Phi'}^{n'},\chi')$ and $(n',\Xi',e')\gg (n'',\Xi'',\chi')$.
\end{theorem}

\begin{proof}
The proof of translation correctness is by induction on the \pqasm program $e$. 
Most of the proof simply shows the correspondence of operations in $e$ to their translated-to gates $\epsilon$ in \sqir, except for \cn{new} and measurement operations, which update the $\Xi$ map.
\end{proof}
% Notice that a \pqasm shifting operation on variable $x$ changes the virtual to physical map from $\gamma$ to $\gamma'$ while generating only \texttt{ID} gates. The map shifting changes the ``world view'' of later operations on $x$, because the qubit physical positions are different between $\gamma$ and $\gamma'$.
% To prove the correctness, for physical positions in $x$, we compare their virtual positions before and after the shifting by using the inverse maps of $\gamma$ and $\gamma'$. Then, we show that difference implements the shifting operation semantics.

%Note that to link a complete, translated oracle $\instr$ into a larger \sqir program may require that $\gamma = \gamma'$, i.e., $\texttt{neutral}(\instr)$, so that logical inputs match logical outputs. This requirement is naturally met for programs written to be reversible, as is the case for all arithmetic circuits in this paper, e.g., \coqe{rz_adder} from \Cref{fig:circuit-example}. % If necessary, the programmer could add dynamic swap instructions manually (encodable in \pqasm).

\ignore{
\begin{lemma}\label{thm:subgroupoid-lemma}\rm
   For all $\epislon \in \{\epsilon^{(\Sigma,\Omega)}\}$, if $\epislon$ is valid operation in $\hsp{S}_n$, $n \le m$, and $\hsp{S}_m$ and it every qubit in $\hsp{S}_m$ satisfies $\Omega$'s restriction, then 
\end{lemma}


We view $(\mathcal{H}, \instr )$ as a groupoid over Hilbert space $\mathcal{H}$, we can then defined a subset of $\mathcal{H}$ as $\mathcal{H}^n_s$, where it has the following conditions:

\begin{itemize}
\item Each element in $\mathcal{H}^n_s$ has the form: $\aket{q_1}{1}\otimes ... \otimes \aket{q_n}{1}$, where $\aket{q_1}{1}$,...,$\aket{q_n}{1}$ are 1-dimensional qubit. 
\item For any element $\aket{q_1}{1}$,...,$\aket{q_n}{1}$ in $\mathcal{H}^n_s$, $\aket{q_i}{1}$ has three possible forms:  $\alpha\aket{c}{n}$, $\frac{1}{\sqrt{2}} \alpha( s_1 \aket{0}{1}+ s_2 \aket{1}{1})$, or $\frac{1}{\sqrt{2}}\alpha~(\aket{0}{1}+\beta\aket{1}{1})$.
\end{itemize}

We view $\Sigma;\Omega\vdash \iota \triangleright \Omega'$ as a predicate for each \pqasm operation $\iota$ on where a program $\iota$ is defined given a subspace $\mathcal{H}_{(x, p)}$, then $(\mathcal{H}^n_s, \instr )$ is a sub-groupoid of $(\mathcal{H}, \instr )$ for all $\instr$ that is type-checked in $\mathcal{H}^n_s$.

We then define a superoperator over $\instr$ as $\instr^*(\rho)= \llbracket \instr \rrbracket \rho \llbracket \instr \rrbracket^{\dag}$ where $\rho \in (\mathcal{H}^n_s)^*$. $(\mathcal{H}^n_s)^*$ is the collection of density matrices seen as linear transformations from $\mathcal{H}^n_s$ to $\mathcal{H}^n_s$.
The superoperator gives the density matrix interpretation of the \pqasm semantics. We define a $2^m$ dimensional database $D$ as $\mathcal{H}^n_s \otimes D$, and $D$ has the format $\aket{q_1}{1}$,...,$\aket{q_{2^n}}{1}$ where $q_i$ is a $k$ array bitstring, each of the bitstring position is either $0$ or $1$.
We define a new operation in $\instr$ as $\texttt{read}\;y\;x$, such that $y$ is a $k$-length qubit, and $x$ is an $m$-length qubit representing the position. The desity matrix semantics of the $\texttt{read}$ operation is given as:

{
\[\Sigma^{2^m-1}_{0}\ket{i}\bra{i}\otimes D_{i}\]
}

With finite bijection mapping $\tget(\rho)$ and $\varrho$, we develop the translation process as the function $(d * \Sigma * \rho * \instr * \varrho) \to (\tucom{d}* \rho * \varrho)$, where $d$ is the dimension number indicating the number of qubits in the system, $\Sigma$ maps variables to qubit numbers in \pqasm, $\rho$ is the position mapping database, $\varrho$ is the inverse function of $\tget(\rho)$, $\instr$ is an \pqasm program, and $\delta\in\tucom{d}$ is a \sqir circuit. 


create a mapping database $\rho$ that maps positions $p$ to a data structure $\coqe{nat} * (\coqe{nat} \to \coqe{nat}) * (\coqe{nat} \to \coqe{nat})$. We assume that all qubit locations in \sqir are managed as a number line counting from $0$. The first \coqe{nat} value is the starting position for an \pqasm variable $x$ on the number line. We assume that $\texttt{start}(\rho,x)$ is a function to get the start position of $x$ in the map $\rho$. The second function ($\mu$, $\coqe{nat} \to \coqe{nat}$) is a mapping from position offset to the offset number of the physical position in \sqir. 
For example, a position $(x,i)$ is mapped to $\tstart(\rho,x)+\mu(i)$ in the number line. The third function ($\nu$, $\coqe{nat} \to \coqe{nat}$) is the inverse function mapping from an offset in \sqir back to the offset in \pqasm. For every offset $i$ for $x$ in \pqasm, if $\mu$ and $\nu$ are the two maps in $\rho(x)$, then $\mu(\nu(i)) = i$, and vice versa. We assume that the actual virtual to physical position mapping is $ \tget(\rho)$, which gets the physical position in \sqir for $p$.
$\tget(\rho,p)$ gives us the \sqir position for $p$ and its definition is $\texttt{start}(\rho,\texttt{fst}(p))+\texttt{get\_}\mu(\rho,\texttt{fst}(p))(\texttt{snd}(p))$.
On the other hand, since different virtual positions map to different physical positions, the function $\tget(\rho)$ is bijective; there is an inverse function $\varrho$ for $\tget(\rho)$, such that $\tget(\rho,p)=i \Rightarrow \varrho(i) = p$. The functions $\rho$, $\tget(\rho)$, and its inverse function $\varrho$ are also useful in the translation process, and we assume that they satisfy \textbf{finite bijection}, where for a set of positions $\overline{p}$, there exists a mapping database $\rho$, a dimension number $d$ and an inverse function $\varrho$, such that for all $p$ in $\overline{p}$, $\tget(\rho,p)=i$, $i<d$, $\varrho(\tget(\rho,p))=p$, and $\tget(\rho,\varrho(i))=i$.}
\ignore{
\begin{definition}\label{def:vars-def}\rm
(\textbf{finite bijection})
Given a virtual to physical position mapping database $\rho$, and the mapping function $\tget(\rho)$, its inverse function $\varrho$, a map from \pqasm variables to its qubit size $\Sigma$, and $d$ is the dimension of the qubits in \sqir and it is a maximum number that is larger than all physical position number in the image of $\tget{\rho}$, we say that $\rho$ and $\varrho$ is finitely bijective iff:

\begin{itemize}
  \item For all $p$, if $\tfst(p))$ is in the domain of $\rho$ and $\tsnd(p)< \Sigma(\tfst(p))$, then $\tget(\rho,p)<d$.
  \item For all $i$, if $i < d$, then $\tfst(\varrho(i))$ is in the domain of $\rho$ and $\tsnd(\varrho(i))< \Sigma(\tfst(\varrho(i)))$
\item For all $p$, if $\tfst(p))$ is in the domain of $\rho$ and $\tsnd(p)< \Sigma(\tfst(p))$, then $\varrho(\tget(\rho,p)) = p$.
\item For all $i$, if $i < d$, then $\tget(\rho, \varrho(i))=i$.
\item For all $p_1$ $p_2$, if $p_1 \neq p_2$, then $\tstart(\rho,p_1) \neq \tstart(\rho,p_1)$.
\item For all $x$ $y$, if $x \neq y$, then for all $i$ $j$, such that $i < \Sigma(x)$ and $j < \Sigma(y)$, $\tget(\rho,(x,i)) \neq \tget(\rho,(y, j))$.
\item For all $p$, if $\tsnd(p) < \Sigma(\tfst(p))$, then $\tget\_\mu(\rho,\tfst(p))(\tsnd(p))<\Sigma(\tfst(p))$.
\item For all $p$, if $i < \Sigma(x)$, then $\tget\_\nu(\rho,x)(i)<\Sigma(x)$.
\end{itemize}

\end{definition}
}

\ignore{
\subsection{\vqimp: A High-Level Oracle Language}\label{sec:qimp}

\begin{figure}[t]
{\footnotesize
\centering
\[\hspace*{-1em}
\begin{array}{c}
\begin{array}{l}
\texttt{fixedp sin}(\textcolor{red}{Q~\texttt{fixedp }x_{/8}},\;\textcolor{red}{Q~\texttt{fixedp }x_r},\;C~\texttt{nat }n)\{
\\[0.2em]
\;\;\textcolor{red}{x_r\texttt{ = }x_{/8};} \;\;C~\texttt{fixedp }n_y;\;\;\textcolor{red}{Q~\texttt{fixedp }x_z;}\;\;
\textcolor{red}{Q~\texttt{fixedp }x_1;}
\\[0.2em]
\;\;
C~\texttt{nat }n_1;\;\;
C~\texttt{nat }n_2;\;\;
C~\texttt{nat }n_3;\;\;
C~\texttt{nat }n_4;\;\;
C~\texttt{nat }n_5;
\\[0.2em]
\;\;\texttt{for }(C~\texttt{nat }i\texttt{ = }0;\; i\texttt{ < }n;\;i\texttt{++})\{\\
\;\;\quad n_1\texttt{ = }i+1;\;\;n_2\texttt{ = }2*n_1;\;\;n_3\texttt{ = }\texttt{pow}(8,n_2);\;\;
          n_4\texttt{ = }n_2+1;
\\[0.2em]
\;\;\quad n_5\texttt{ = }n_4!;\;\;n_y\texttt{ = }n_3 / n_5;\;\;
\textcolor{red}{x_z\texttt{ = }\texttt{pow}(x_{/8},n_4);}\\[0.2em]
\;\;\quad \texttt{if }(\texttt{even}(n_1))\;\;{\{
\textcolor{red}{{x_1}\texttt{ = }{n_y}*{x_z};\;\;
x_r\texttt{ += }{x_1};}

\}}\\[0.2em]
\;\;\quad\texttt{else } {\{\textcolor{red}{{x_1}\texttt{ = }{n_y}*{x_z};\;\;{x_r}\texttt{ -= }{x_1};}\};}\\[0.2em]
\;\;\quad\textcolor{red}{\texttt{inv}(x_1);\;\;\texttt{inv}(x_z);}

\}\\
\;\;\texttt{return }\textcolor{red}{(8*x_r)};\\
\}
\end{array}\\[8em]
\sin{x}\approx 8*(\frac{x}{8}-\frac{8^2}{3!}(\frac{x}{8})^3+\frac{8^4}{5!}(\frac{x}{8})^5-\frac{8^6}{7!}(\frac{x}{8})^7+...+(-1)^{n-1}\frac{8^{2n-2}}{(2n-1)!}(\frac{x}{8})^{2n-1})
\end{array}
\]
}
\vspace*{-1em}
\caption{Implementing sine in \vqimp}
\label{fig:sine-impl}
\end{figure}

It is not uncommon for programmers to write oracles as metaprograms in
a quantum assembly's host language, e.g., as we did for \coqe{rz_adder} in
\Cref{fig:circuit-example}. But this process can be tedious and error-prone,
especially when trying to write optimized code.
%
To make writing efficient arithmetic-based quantum oracles easier,
we developed \vqimp, a higher-level imperative language that compiles
to \pqasm. Here we discuss \vqimp's basic features, describe how we 
optimize \vqimp programs during compilation using partial
evaluation, and provide correctness guarantees for \vqimp programs. 
Using \vqimp, we have defined operations for the ChaCha20 hash-function \cite{chacha}, exponentiation, sine, arcsine, and cosine, and tested program correctness by running inputs through \vqimp's semantics. 
%
More details about \vqimp are available in \cite{vqoex} Appendix B.

\myparagraph{Language Features}

An \vqimp program is a sequence of function definitions, with the last
acting as the ``main'' function. Each function definition is a series
of statements that concludes by returning a value $v$.  \vqimp statements contain
variable declarations, assignments (e.g., $x_r\texttt{ = }x_{/8}$ in \Cref{fig:sine-impl}),
arithmetic computations ($n_1\texttt{ = }i+1$), loops, conditionals,
and function calls.
%In declarations, all variables are initialized as $0$.
Variables $x$ have types $\tau$, which are either primitive types
$\omega^m$ or arrays thereof, of size $n$. A primitive type pairs a
base type $\omega$ with a \emph{quantum mode} $m$. There are three base
types: type $\tnat$ indicates non-negative (natural) numbers; type
$\tfixed$ indicates fixed-precision real numbers in the range $(-1,1)$;
and type $\tbool$ represents booleans. The programmer specifies the
number of qubits to use to represent $\tnat$ and $\tfixed$ numbers
when invoking the \vqimp compiler.  
%
The mode $m \in\{C, Q\}$ on a primitive type indicates when a
type's value is expected to be known: $C$ indicates that the value is based
on a classical parameter of the oracle, and should be known at compile
time; $Q$ indicates that the value is a quantum input to the oracle, 
computed at runtime. 

\Cref{fig:sine-impl} shows the \vqimp implementation of the sine function,
which is used in quantum applications such as Hamiltonian
simulation~\cite{feynman1982simulating,Childs_2009}. 
Because $\tfixed$ types must be in the range $(-1,1)$, the function
takes $\frac{1}{8}$ times the input angle in variable $x_{/8}$ (the input 
angle $x$ is in $[0,2\pi)$). The result, stored in variable $x_r$, 
is computed by a Taylor expansion of $n$ terms.
The standard formula for the Taylor expansion is
$\sin{x}\approx
x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+...+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}$;
the loop in the algorithm computes an equivalent formula given input
$\frac{1}{8}x$, as shown at the bottom of the figure. 
% Performing this manual transformation is tedious, but allows for
% the significant reduction in qubits required to represent a
% $\tfixed$. We can use property testing to help assure the
% transformation is correct; automating the transformation would be
% interesting future work.

% The return value $8*x_r$ in \Cref{fig:sine-impl} is automatically computed by \vqimp.
% Programmers can set a flag $n$ for a $\tfixed$ variable $x$
% and \vqimp will automatically convert the value of $x$ to $\frac{x}{n}$, like $x_{/8}$ in \Cref{fig:sine-impl}, and multiply $n$ back to the return result, like $8*x_r$.
% \khh{But even if \vqimp adds the multiplication by 8, the user still has to write their algorithm with $x/8$ in mind, right? (E.g., ``pow(8,n2)'' in the code.) This doesn't seem very automatic.}

% Another feature of \vqimp is \emph{reversibility}; we provide two kinds.
% First, every \vqimp function call is reversible. For example, in a call to the \texttt{sin} function, excluding the computed result $x_r$, the side-effects on input variables, e.g., $x_{/8}$, are uncomputed once the call returns. 
% Second, \vqimp's \texttt{inv} operation can be used to manually uncompute a single assignment of a variable.
% For example, $\texttt{inv}(x_1)$ in \Cref{fig:sine-impl} uncomputes $x_1$ in every loop iteration.
% To implement this, we maintain a stack during compilation that tracks the nearest assignment of a variable.
% See \Cref{sec:appendix} for more details.

\myparagraph{Reversible Computation}
\label{sec:revcomp}

Since programs that run on quantum computers must be
\emph{reversible}, \vqimp compiles functions to reverse their
effects upon returning. In \Cref{fig:sine-impl}, after the
\texttt{main} function returns, only the return value is copied and
stored to a target variable. For other values, like $x_{/8}$, the 
compiler will insert an \emph{inverse circuit} to revert all side effects.

When variables are reused within a function, they must be
\emph{uncomputed} using \vqimp's $\sinv{x}$ operation. For
example, in \Cref{fig:sine-impl}, the second \texttt{inv} operation
returns $x_z$ to its state prior to the execution of
$\textcolor{red}{x_z\texttt{=}\texttt{pow}(x_{/8},n_4)}$ so that $x_z$ 
can be reassigned in the next iteration.
We plan to incorporate automatic uncomputation techniques to insert $\sinv{x}$ calls automatically, but doing so requires care to avoid blowup in the generated circuit \cite{unqomp}. 

The \pqasm compiler imposes three restrictions on the use of $\sinv{x}$, 
which aim to ensure that each use uncomputes just one assignment to $x$.
%
First, since the semantics of an \texttt{inv} operation reverses the
most recent assignment, we require that every \texttt{inv} operation
have a definite predecessor. Example \texttt{(1)} in \Cref{fig:inv-examples}
shows an \texttt{inv} operation on a variable that does not have a
predecessor; \texttt{(2)} shows a variable $z$ whose
predecessor is not always executed. Both are invalid in \vqimp.
Second, the statements between an \texttt{inv} operation and its
predecessor cannot write to any variables used in the body of the
predecessor. Example \texttt{(3)} presents an invalid case where $x$
is used in the predecessor of $z$, and is assigned between the
\texttt{inv} and the predecessor.  The third restriction is that, while
sequenced \texttt{inv} operations are allowed, the number of \texttt{inv}
operations must match the number of predecessors. Example \texttt{(4)}
is invalid, while \texttt{(5)} is valid, because the first
\texttt{inv} in \texttt{(5)} matches the multiplication assignment
and the second \texttt{inv} matches the addition assignment.

\begin{figure}[t]
\footnotesize
\[
\begin{array}{c}
\texttt{(1)}
\begin{array}{l}

a\texttt{=}x\texttt{ * }y;
\\
\texttt{inv}(z);
\textcolor{red}{\xmark}
\end{array}
\quad
\texttt{(2)}
\begin{array}{l}
\texttt{if}(x<y)\\
\;\;\;a\texttt{=}x\texttt{ * }y;\\
\texttt{else}\\
\;\;\;z\texttt{=}x\texttt{ * }y;
\\
\texttt{inv}(z);
\textcolor{red}{\xmark}
\end{array}

\quad
\texttt{(3)}
\begin{array}{l}

z\texttt{=}x\texttt{ * }y;
\\
x\texttt{=}x\texttt{ + }1;
\textcolor{red}{\xmark}
\\
\texttt{inv}(z);
\end{array}
\quad
\texttt{(4)}
\begin{array}{l}

z\texttt{=}x\texttt{ * }y;
\\
\texttt{inv}(z);
\\
\texttt{inv}(z);
\textcolor{red}{\xmark}
\end{array}
\quad
\texttt{(5)}
\begin{array}{l}

z\texttt{+=}x;
\\
z\texttt{=}x\texttt{ * }y;
\\
\texttt{inv}(z);
\\
\texttt{inv}(z);
\end{array}
\textcolor{green}{\cmark}
\end{array}
\]
\caption{Example (in)valid uses of \texttt{inv}}\label{fig:inv-examples}
\end{figure}

To implement these well-formedness checks, \pqasm's \vqimp compiler maintains a 
stack of assignment statements. Once the compiler hits an \texttt{inv}
operation, it pops statements from the stack to find a match
for the variable being uncomputed. It also checks that none of the popped
statements contain an assignment of variables
used in the predecessor statement.
}
